# siegeNgin アーキテクチャ設計

## ビジョン

人間同士が会議室で **声とホワイトボード** を使って意思疎通するように、
AIとの協働でも **チャットとコラボレーションツール** を併用した意思疎通を実現する。

チャットだけのAI協働は「電話会議」に等しい。
siegeNginは、AIと人間が **同じものを同時に見ながら会話する** ための共有空間（ホワイトボード）を提供する。

## 課題：チャットだけでは壁がある

### 視覚的コンテキストの欠如

```
人間: 「Y軸のラベルをもう少し左に」
AI:   「anchor=east で pos=0 にしますか？」
人間: 「いや、そうじゃなくて…」
      （数往復のやりとり）
```

図・レイアウト・UIの調整は、言語化のコストが極めて高い。
「ここ」と指させれば一瞬で伝わることに、何往復もかかる。

### データの共有が困難

```
人間: 「スプレッドシートの3行目のデータをこのフォームに入れて」
AI:   「どのスプレッドシートですか？どのシートですか？」
```

データソースと操作対象が分断されていて、AIが両方を同時に見られない。

## コンセプト：3つの層

### 1. チャット層（声）

意図・議論・指示を伝える。

- 既存のメッセージングツール（Telegram、Discord、Slack等）をそのまま利用
- AIエージェント基盤（OpenClaw等）が仲介

**siegeNginはチャット層を再発明しない。** 既存のエコシステムを活用する。

### 2. 共有ビュー層（ホワイトボード）

AIと人間が同じコンテキストを共有するブラウザベースのUI。

複数のツールを同時に表示し、共有する窓：

| ツール | 役割 | 例 |
|--------|------|-----|
| スプレッドシート | データソース | Google Sheets, CSV |
| ブラウザビュー | 操作対象 | 業務フォーム, Webアプリ |
| プレビュー | 出力結果 | PDF, 画像, コード差分 |
| エディタ | 共同編集 | コード, 設計図 |

### 3. ポインティング層（指さし）

「これ」「ここ」を伝えるインタラクション。

- ユーザがクリック/選択した要素をAIのコンテキストに変換
- AIが理解可能なインターフェース（セレクタ、座標、セル参照等）を自動生成

## コア機能

### インターフェース自動生成

既存のWebページやツールを読み込み、ユーザの「指さし」から操作可能なインターフェースを自動生成する。

**先行実装: XPathGenie / Jasmine**

Jasmineは、既存Webページの要素をクリックで選択すると、XPath（操作パス）を自動生成する。
これはsiegeNginのインターフェース自動生成のプロトタイプにあたる。

```
既存Webサイト → 読み込み → ユーザが指さす → インターフェースを自動生成
```

この仕組みを汎用化する：

- Webページの要素 → DOM セレクタ / XPath
- スプレッドシートのセル → セル参照（A3, B7等）
- PDF/画像の領域 → 座標・バウンディングボックス
- フォームの入力欄 → フィールド識別子

### マスター自動判定

チャット側のユーザと共有ビュー側のユーザを自動的に紐付ける。
コラボレーションツールの認証情報を利用し、コマンドライン設定なしでユーザを特定する。

### ブリッジ

共有ビュー上のユーザ操作を、AIエージェントのコンテキストにリアルタイムで伝達する。

```
[ユーザ操作]              [AIコンテキスト]
セルB3をクリック     →    「スプレッドシートの B3（値: 田中太郎）を選択」
フォーム欄を指さし   →    「入力先: #name-field（ラベル: 氏名）」
PDF領域を選択       →    「PDF 2ページ目、左上 (120,340) 付近のラベル」
```

## 設計原則

### 1. 既存ツールを活かす

siegeNginは既存のエコシステムを置き換えない。

- チャット → 既存メッセージングツール
- AIエージェント → OpenClaw等の既存基盤
- データ → Google Sheets等の既存サービス

siegeNginが担うのは **「つなぎ」** — 分断されたツール間の共有コンテキストを生む。

### 2. ブラウザベース、サーバーレス志向

- コマンドライン不要
- 可能な限りクライアントサイドで完結
- 参入障壁を最小化

### 3. 指さしファースト

言語化が難しいことは、指さしで伝える。
GPUのように高速に視覚処理できる人間の能力を活かし、
言語ボトルネックを回避する設計。

## 既存資産との関係

| プロジェクト | siegeNginにおける位置づけ |
|-------------|------------------------|
| XPathGenie / Jasmine | インターフェース自動生成のプロトタイプ |
| ChatBot Lite | $0ブラウザUI設計パターン |
| OpenClaw | チャット層のAIエージェント基盤 |
| playwright-cli | AIからブラウザを操作する技術 |

## データフローとセキュリティ

### latest.json の保護方針

Chrome拡張から送られたポイントデータは、サーバーローカルの `latest.json` にフルデータ（テキスト内容・属性値を含む）で保存される。本隊（AIアシスタント）はこのファイルを直接読むため、城門のフィルタを経由しない。

- **パーミッション**: `0600`（所有者のみ読み書き）
- **保持期間**: 新しいポイントで上書き。履歴は直近10件のみ保持
- **配置先**: ユーザー所有ディレクトリ（`~/.local/share/siegengin/`）。`/tmp` は使用しない
- **サーバー侵害時**: `latest.json` が最も価値の高い標的となる。サーバー自体のセキュリティ（SSH鍵認証、ファイアウォール等）が前提

### Wakeメカニズム

足軽（伝令）がポイントデータを受け取った後、本隊を起こすトリガー：

1. 足軽がサーバーローカルにデータを書き込み
2. サーバーがAIエージェント基盤（OpenClaw等）にWakeイベントを送信（localhost webhook）
3. 本隊がWakeで起動 → `latest.json` を読み取り → チャットチャネルで応答

Wakeはサーバー内部のlocalhost通信であり、城門を通らない。外部からのWake発火は不可。

## 今後の検討事項

- [ ] 共有ビューのUI設計（マルチペイン? タブ? フローティング?）
- [ ] ブリッジのプロトコル設計（WebSocket? postMessage?）
- [ ] 対応ツールの優先順位（スプレッドシート、フォーム、PDF…）
- [ ] リアルタイム性の要件（同期的? 非同期?）
- [ ] セキュリティモデル（APIキーの扱い、BYOK?）
- [ ] OpenClawとの統合方式
